EMBEDDING

- When you declare a function f with let, but then add some other
  rule (like p x y -> f x y), f ceases to behave like a function.
  It might be an issue with Either.clausify, a problem with the
  embedding, a more general problem with how negation is being
  handled, or something else entirely, so we'll have to be patient.

- Total orders with 'next' leave lots of 'hanging' facts about the
  out-of-bounds constant next of the last element.

GRID

- I got stuck with the visualization / verification part.

- The approach taken with objects.py (first write procedural
  tests checking if a certain Python object has a property,
  then write a function that turns a relational specification
  into that Python object, and check it using a testing framework,
  which allows very fast, repeatable and hassle-free iteration)
  worked, so we should try that again (maybe using some of the
  same functions for trees).

FUNCTIONS

- I got stuck with the debugging part (is the logic program
  wrong, is there a bug in the program, or is there a bug
  in some assumption there? - some issue with negation, or
  an incomplete translation)

- So far these are working in lots of contexts

- Equality and 'actual functions' can be implemented using
  these. You can have a function assign : A' -> A, and since
  each a' is assigned exactly one a, that can be used as some
  form of equality (together with p(a'), assign(a', a) <-> p (a))

  The arity of predicates and rules can be reduced using that
  kind of workaround, which reduces the size of embeddings, since
  assign (a.f, b) lets you assert stuff about b without explicit
  references to anything other than a (unfolding iterates only
  over a's sort, as in 'p(a), q(a.f), r(a.g), s(a.f, a.g) -> t(a, a.g)',
  which will be especially useful when using DRTs and working
  with local properties of nodes that involve lots of arguments.

SYMMETRY BREAKING

- using totally ordered sorts works as long as there are no
  'loose' predicates that can be true or false for the same
  model, when you only consider 'structurally relevant' predicates.
  In the example of trees, many models did not differ in who
  was left of whom, but did differ in some of the 'auxiliary' predicates,
  so their trees were isomorphic, but showed up more than once while
  enumerating models.


INTERFACE / COUPLING / MODULARITY

The current interface does not let you use pysat's 'solve with'
(you cannot say 'hey, give me a model using the current state, but
temporarily add the literals in L to it. Give me just one model, then
forget'). I don't think pysat lets you iterate over more than one model
that way.

MODELING

- The relational specification of parsing tilings / 2D strings is
  still very sketchy. Using a leveled DAG looks promising, as well
  as 'storing semantic data' (same as DRT, but a bit simpler), but
  I'm not sure how to properly represent spatial information.
  
  A possible workaround is to 'hardcode' spatial hierarchy data
  ('A large area is a rectangle with NM tiles. Large areas may
  contain small and mid areas, and all areas within a large
  area must be mutually accessible', and so on). Since only valid
  tilings should be produced, and no valid large area should have
  just one small child, this could be made to work, although it is
  very ad-hoc.
  
  Using corners seems like a more general alternative ('all children
  of an area must be within the bounds of its corners'), and probably
  could be generalized to convex shapes very easily. Corner data could
  be 'stored' in a vertex's DRS, and reasoning about total orders is
  easy with what we already have (and we want to model arithmetic anyway,
  so that should be ready at some point).
